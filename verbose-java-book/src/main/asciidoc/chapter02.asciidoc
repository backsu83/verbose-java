== Numbers and Characters

[quote, Unknown]
________________________________________________________________________________
컴퓨터는 0과 1밖에 모르는 바보다.
________________________________________________________________________________

[quote, 지은이]
________________________________________________________________________________
0과 1밖에 모르는 컴퓨터보다 똑똑한 사람을 만난 적은 없다.
________________________________________________________________________________

본 장에서는 '`숫자`'밖에 모르는 컴퓨터와 '`문자`'를 사용하는 사람과의 사이에 종종 발생하는 문제점들을 해결해는 방법들을 살펴본다. 우선 자바의 자료형에 대해 간략하고 알아본 후 [http://tools.ietf.org/html/rfc4648#section-8[Base 16 Encoding(RFC 4648)]]과 [https://tools.ietf.org/html/rfc3986#section-2.1[Percent-Encoding (RFC 3986)]]에 대해 알아보자.

=== Types and Values

****
자바의 `int` 형은 몇 비트인가요? `signed` 인가요? 아니면 `unsigned` 인가요? 표현할 수 있는 최소값과 최대값은 무엇인가요?
****

위의 질문들에 대한 올바른 답을 아직 모른다면 [https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html[JSL 4. Types, Values, and Variables]] 항목을 꼭 읽어보도록 하자. 원시형을 중심으로 해당 항몬을 요약하자면 다음과 같다.

- 자바 프로그래밍 언어에는 두가지 데이터 형이 있다. 하나는 원시형(primitive types)이고 또 다른 하나는 참조형(reference types)이다.
- 원시형(primitive types)에는 `boolean` 과 수치형(numeric types)이 있다.
- 수치형(numeric types)에는 정수형(integral types)과 부동소수점형(floating-point types)이 있다.
- 정수형(integral types)에는 `byte`, `short`, `int`, `long`, 그리고 `char` 가 이다.
- 부동소수점형(floating-point types)에는 `float` 과 `double` 이 있다.

[options="header"]
.Primitive types
|==================================================
|type       |                 |        |size|signed
|NumericType|IntegralType     |`byte`  | `8`|yes
|           |                 |`short` |`16`|yes
|           |                 |`int`   |`32`|yes
|           |                 |`long`  |`64`|yes
|           |                 |`char`  |`16`|
|           |FloatingPointType|`float` |`32`|yes
|           |                 |`double`|`64`|yes
|`boolean`  |                 |        |    |
|==================================================

****
자바의 정수형(integral types) 중에 unsigned 형이 존재하는가? 있다면 무엇인가?
****

=== N-bit signed two's-compliment integers
N개의 비트로 이루어져 있고 부호를 가지며 2의 보수체계를 사용하는 정수형로 표현할 수 있는 값의 범위는 무엇일까? 아래 세개의 비트를 가지고 실험해 보자. `000` 부터 시계방향으로 1씩 더하면서 계산해 보자.

[source,text]
.3-bit signed two's-compliment integer
----
       +1
         \ 000  0
  -1  111 \ 001  1
   -2  110 \ 010  2
    -3  101 \ 011  3  MAX
MIN  -4  100 \
              +1
----

보는 바와 같이 `011` 에서 `1` 을 더했을때 `100` 이 되지만 첫번째 비트가 `1` 이므로 음수(`-4`)로 처리된다. 최대값은 첫번째 비트가 `0` 이고 나머지 모든 비트가 `1` 인 값이고 최소값은 첫번째 비트가 `1` 이고 나머지 비트가 모두 `0` 인 값이다. 이를 수식으로 표현하면 최대값은 `+2^n-1^-1` 이고 최소값은 `-2^n-1^` 이다.

****
크기가 1 비트이고 부호를 가지며 2의 보수 체계를 사용하는 정수형으로 표현할 수 있는 최대값과 최소값은 무엇인가?
****

=== hex-codec-api

보통의 (거의 모든) 컴퓨터들은 자료를 저장할 때 여덟개의 비트로 구성된 최소 단위로 나누어 저장한다. 우리가 일반적으로 사용하는 모든 파일들(텍스트, 이미지, 오디오, 동영상 등)이 모두 이 `octet` 이라고 불리는 숫자로 나누어 저장된다. `'a'` 라는 문자는 `01100001` 로, `'홍'` 이라는 문자는 (`UTF-8` 로 인코딩 되었을 때) `111011011 00110011 0001101` 로 저장된다. 아래 표에 여덟개의 비트로 표현할 수 있는 몇몇 값들을 10진법, 8진법, 2진법, 그리고 자바의 `byte` 값으로 표현하였다.

[cols=">1,>1,>1,>1,<2",frame="top",options="header"]
.8-bit values
|===============================================
|base10 |base8|base2     |byte  |notes
|   `0`|  `0`|       `0`|   `0`|
|  `15`| `17`|    `1111`|  `15`|
|  `31`| `37`|   `11111`|  `31`|
|  `63`| `77`|  `111111`|  `63`|
| `127`|`177`| `1111111`| `127`|`Byte.MAX_VALUE`
| `128`|`200`|`10000000`|`-128`|`Byte.MIN_VALUE`
| `192`|`300`|`11000000`| `-64`|
| `224`|`340`|`11100000`| `-32`|
| `240`|`360`|`11110000`| `-16`|
| `255`|`377`|`11111111`|  `-1`|
|===============================================

자바의 `byte` 형은 여덟개의 비트를 사용하고 부호를 가지며 2의 보수체계를 사용한다.

[source,text]
.8-bit signed two's-compliment integer
----
                         +1
                           \ 00000000  0
               -1  11111111 \ ........
                    ........ \ ........
                     ........ \ 01111111  127  Byte.MAX_VALUE
Byte.MIN_VALUE  -128  10000000 \
                                +1
----

거의 모든 문자셋의 기본이 되는 `US-ASCII` 문자셋에는 줄바뀜(CR, LF), 탭(TAB) 등의 제어 문자들과 보통의 자판에서 찾아볼 수 있는 문자들을 포함하여 `128`(`2^7^`)개의 코드가 정의되어 있다. 때문에 여덟개의 비트로 표현할 수 있는 `256`(`2^8^`)개의 수에 모든 문자를 할당하는 것이 불가능하다. 이를 해결하는 방법 중에 하나가 `base16`(`hex`) 로 표현하는 것이다. `base16` 표기는 여덟 개의 비트를 네 개씩 두 그룹으로 나눈 후에 각 그룹의 값을 미리 정의된 문자로 표현한다.

우선 아래와 같이 여덟 개의 비트를 네 개씩 두 그룹으로 나눈다.

[source,text]
----
index  7 6 5 4 3 2 1 0
upper  H H H H
lower          L L L L
----

그리고 (네 개의 비트로 구성된) 각 그룹의 값을 아래 표에 정의된 열 여섯개(`2^4^`)의 문자로 변경한다.

[cols=">, >, >, >", options="header"]
.hexadecimal encoding/decoding
|============================================================
|decoded binary|decoded value|encoded character|encoded value
|           `0`|    `0 (0x0)`|            `'0'`|  `48 (0x30)`
|           `1`|    `1 (0x1)`|            `'1'`|  `49 (0x31)`
|          `10`|    `2 (0x2)`|            `'2'`|  `50 (0x32)`
|          `11`|    `3 (0x3)`|            `'3'`|  `51 (0x33)`
|         `100`|    `4 (0x4)`|            `'4'`|  `52 (0x34)`
|         `101`|    `5 (0x5)`|            `'5'`|  `53 (0x35)`
|         `110`|    `6 (0x6)`|            `'6'`|  `54 (0x36)`
|         `111`|    `7 (0x7)`|            `'7'`|  `55 (0x37)`
|        `1000`|    `8 (0x8)`|            `'8'`|  `56 (0x38)`
|        `1001`|    `9 (0x9)`|            `'9'`|  `57 (0x39)`
|        `1010`|   `10 (0xA)`|            `'A'`|  `65 (0x41)`
|        `1011`|   `11 (0xB)`|            `'B'`|  `66 (0x42)`
|        `1100`|   `12 (0xC)`|            `'C'`|  `67 (0x43)`
|        `1101`|   `13 (0xD)`|            `'D'`|  `68 (0x44)`
|        `1110`|   `14 (0xE)`|            `'E'`|  `69 (0x45)`
|        `1111`|   `15 (0xF)`|            `'F'`|  `70 (0x46)`
|============================================================

NOTE: `10` 부터 `15` 까지의 숫자를 소문자(`'a'` 부터 `'f'`)로 변환해도 된다.

아래는 `hello, world` 가 `base16` 으로 인코딩될 때 적용되는 방식을 보여준다.

[source,text]
----
    0                    7                      15                      23
    h  e  l  l  o  , SP  w  o  r  l  d
   -- -- -- -- -- -- -- -- -- -- -- --
0x 68 65 6C 6C 6F 2C 20 77 6F 72 6C 64
   --
    \
   -- --
    6  8  6  5  6  C  6  C  6  F  2  C  2  0  7  7  6  F  7  2  6  C  6  4
   -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
0x 36 38 36 35 36 43 36 43 36 46 32 43 32 30 37 37 36 46 37 32 36 43 36 34
----

첫번째 문자 'h' 의  ascii 값은 `104`(`0x68`)이다. 이를 이진수로 표현하면 `01101000` 이고 이를 각 네 자리씩으로 나눈 `0100(6)` 과 `1000(8)` 에 해당하는 문자 '6' 의 ascii값인 `54` 와 '8' 의 ascii값인 `56` 이 결과값이다.

[source,text]
----
'h' = 0110 1000  (104, 0x68)
      0110       (  6, 0x06)    =>    '6' = 0011 0110  ( 54, 0x36)
           1000  (  8, 0x08)    =>    '8' = 0011 1000  ( 56, 0x38)
----

hex-codec-api 모듈에는 `base16` 을 위한 두 개의 인터페이스가 정의되어 있다.

==== HexEncoder.java

`base16` 인코딩을 위한 인터페이스이다.

[source,java]
.HexEncoder.java
----
@FunctionalInterface
public interface HexEncoder {

    // 주어진 숫자(octet)를 인코딩하여 hex 문자 두개를 버퍼에 담는다.
    void encodeOctet(int decoded, ByteBuffer encoded);
}
----

`HexEncoder` 인터페이스에는 몇개의 `default` 메서드들이 정의되어 있다.

[source,java]
.HexEncoder.java#encode(ByteBuffer, ByteBuffer)
----
    // decoded 버퍼의 바이트들을 인코딩하고 그 결과를 encoded 버퍼에 담는다.
    // decoded 버퍼에서 소비된 바이트의 개수를 반환한다.
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoder.java[lines=40..47]
----
<1> `decoded` 버퍼에 읽을 바이트가 있고 `encoded` 버버에 최소한 두 개의 바이트를 담을 수 있는 동안 `encode(int, ByteBuffer)` 를 호출한다.

[source,java]
.HexEncoder.java#encode(ByteBuffer)
----
    // encoded 버퍼의 모든 바이트들을 인코딩하고 결과를 새 버퍼에 담아 반환한다.
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoder.java[lines=56..62]
----
<1> `decoded` 버퍼에서 읽을 수 있는 바이트 개수의 두 배만큼의 버퍼를 생생한 후 `encode(ByteBuffer, ByteBuffer)` 메서드를 호출한다.

[source,java]
.HexEncoder.java#encode(String, Charset)
----
    // 주어진 문자열(encoded)을 코딩하고 결과를 문자열로 반환한다.
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoder.java[lines=72..78]
----
<1> `charset` 을 이용해 주어진 문자열에서 입력 배열을 생성한다.
<2> 두배의 길이를 갖는 출력 배열을 생성한다.
<3> 이 두 배열을 감싸는 버퍼들을 이용해 `encoded(ByteBuffer, ByteBuffer)` 를 호출한다.
<4> 출력 배열로부터 문자열을 생성하고 반환한다.

==== HexDecoder.java

`base16` 디코딩을 위한 인터페이스이다.

[source,java]
.HexDecoder.java
----
@FunctionalInterface
public interface HexDecoder {

    // 버퍼에서 hex 문자 두개를 디코딩하고 그 결과값(octet)을 반환한다.
    // 버퍼가 두개 이하의 바이트를 담고 있으면 BufferUnderflowException 을 던진다.
    int decodeOctet(ByteBuffer encoded);
}
----

`HexDecoder` 인터페이스에도 `HexEncoder` 인터페이스에 정의된 `default` 메서드들과 대응하는 `default` 메서드들이 정의되어 있다.

==== HexEncoderStream.java

한 개의 바이트가 기록될 때 자동으로 두 개의 `base16` 문자들로 바꾸어 기록하는 `OutputStream` 이다. `java.io.FilterInputStream` 클래스를 확장하여 작성되었다.

[source,java]
.HexEncoderStream.java
----
public class HexEncoderStream extends FilterOutputStream {

    public HexEncoderStream(final OutputStream out, final HexEncoder enc) {
        super(out);
        this.enc = enc;
    }

    protected HexEncoder enc;
    private ByteBuffer buf;
}
----

다음과 같이 `write()` 메서드가 재작성되었다.

[source,java]
.HexEncoderStream.java#write(int)
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoderStream.java[lines=50..60]
----
<1> `buf` 가 `null` 이면 두개의 hex 문자를 담을수 있을 만큼의 크기로 생성한다.
<2> `HexEncoder` 인터페이스의 `encode(int, ByteBuffer)` 메서드들 이용해 주어진 바이트를 변환한다.
<3> 변환된 두개의 hex 문자들을 `out` 필드에 기록한다.

****
`FilterOutputStream` 클래스의 생성자는 `out` 인자가 `null` 인지 확인하지 않는다. 대신 `protected` 접근자를 가지는 `out` 필드를 통해 값을 수정할 수 있다. 아마도 `null` 을 이용하여 생성한 후 실제로 사용할 필요가 있을 때 게으르게(lazily) 초기화될(initialized) 수 있는 여지를 남겨둔 듯 하다. `HexEncoderStream` 클래스의 생성자도 `enc` 인자가 `null` 인지 확인하지 않는다. `null` 값을 이용하여 생성한 후 다음과 같이 사용할 수도 있다.
[source,java]
----
final OutputStream hos = new HexOutputStream(null, null) {
    @Override public void write(final byte b) {
        if (out == null) out = out();
        if (enc == null) enc = enc();
        super.write(b);
    }
};
----
주의 할 점은 `flush()`, `close()` 등의 메서드들이 `out` 필드가 `null` 인지 확인하지 않는다.
[source,java]
.FilterOutputStream.java (http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/java/io/FilterOutputStream.java[7u40-b43])
----
public void flush() throws IOException {
    out.flush();
}
public void close() throws IOException {
    try {
      flush();
    } catch (IOException ignored) {
    }
    out.close();
}
----
최근의 소스를 보면 다음과 같이 수정되었지만 여전히 `flush()` 메서드에서는 `out` 필드의 값을 확인하지 않고 사용한다.
[source,java]
.FilterOutputStream.java (http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/io/FilterOutputStream.java[8u40-b25])
----
public void flush() throws IOException {
    out.flush();
}
public void close() throws IOException {
    try (OutputStream ostream = out) { // <1>
        flush();
    }
}
----
<1> `ostream` 이 `null` 이면 `close()` 를 호출하지 않는다.
****

==== HexDecoderStream.java

`HexDecoder` 인터페이스를 이용하여 두개의 hex 문자들을 하나의 바이트로 바꿔서 읽어들이는 `InputStream` 이다. `FilterInputStream` 을 확장하여 만들어졌다.

[source,java]
.HexDecoderStream.java
----
public class HexDecoderStream extends FilterInputStream {

    public HexDecoderStream(final InputStream in, final HexDecoder dec) {
        super(in);
        this.dec = dec;
    }

    protected HexDecoder dec;
    private ByteBuffer buf;
----

다음과 같이 `read()` 메서드를 재정의 하여 두개의 바이트들을 읽고 하나로 디코딩한 후 반환한다.

[source,java]
.HexDecoderStream.java#read()
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexDecoderStream.java[lines=51..70]
----
<1> `buf` 값이 아직 `null` 이면 두개의 hex 문자를 담을 수 있을 만큼의 크기로 생성한다.
<2> 첫번째 바이트를 읽고 `buf` 에 담는다. 그 값이 `-1` 이면 `-1` 을 반환한다.
<3> 두번째 바이트를 읽고 `buf` 에 담는다. 그 값이 `-1` 이면 `EOFException` 을 던진다. (올바르게 인코딩되었다면 두 개의 hex 문자들이 올바르게 읽혀져야 한다.)
<4> `HexDecoder` 인터페이스의 `decodeOctet(ByteBuffer)` 메서드를 이용하여 디코딩한 값을 반환한다.

부가적으로 다음의 메서드들이 `InputStream` 클래스에서 정의된 본래의 목적에 맞게 동작하도록 재구현되었다.

- `FilterInputStream` 클래스의 `read(byte[], int, int)` 메서드는 `in` 필드에 직접 `read(byte[], int, int)` 메서드를 호출한다. 다음과 같이 재정의된 `read()` 메서드를 호출하도록 재정의되었다.
+
[source,java]
.HexDecoderStream.java#read(byte[], int, int)
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexDecoderStream.java[lines=85..106]
----
<1> `len` 만큼 `read()` 메서드가 `-1` 을 반환하기 전까지 호출한다. 첫 바이트가 `-1` 이면 `-1` 을 반환한다.

- `mark(int)` 메서드에 주어진 값의 두 배를 실제로 사용한다. (두개의 문자를 읽어서 하나로 반환하므로 두 배의 값을 사용한다.)
+
[source,java]
.HexDecoderStream.java#mark(int)
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexDecoderStream.java[lines=117..125]
----
<1> 두 배의 값을 사용하기 위해 인자의 최대치를 반으로 줄인다.
+
CAUTION: `reallimit` 이라는 변수의 이름이 `readlimit` 이라는 인자의 이름과 비슷하여 혼란을 초래할 수 있다.

- `available()` 메서드가 반환하는 값을 반으로 줄인다.
+
[source,java]
.HexDecoderStream.java#available()
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexDecoderStream.java[lines=139..142]
----

- `skip(long)` 메서드는 `-1` 이 읽혀지기 전까지 `n` 만큼 `read()` 메서드를 호출한다.
+
[source,java]
.HexDecoderStream.java#skip(long)
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexDecoderStream.java[lines=155..160]
----

==== HexEncoderChannel.java

`HexEncoder` 인터페이스를 이용해 `write(ByteBuffer)` 메서드에 전달된 버퍼의 값을 자동으로 인코딩하여 기록하는 체널이다. `FilterOutputStream` 과 같은 클래스가 존재하지 않으므로 직접 `WritableByteChannel` 을 구현하여 사용한다.

[source,java]
.HexEncoderChannel.java
----
public class HexEncoderChannel implements WritableByteChannel {

    // channel: 실제로 인코딩된 데이터가 기록될 채널
    // encoder: 인코딩에 사용할 인코더
    // capacity: 인코딩 버퍼의 용량
    // direct: true 이면 인코딩 버퍼를 생성할 때 다이렉트 버퍼를 생성한다
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoderChannel.java[lines=38..50]

    protected WritableByteChannel channel;
    protected HexEncoder encoder;
    private final int capacity;
    private final boolean direct;
    private ByteBuffer buffer;
}
----
<1> 인코딩 버버의 크기는 최소한 2보다 커야 한다.

`write(ByteBuffer)` 메서드를 구현하기 전에 `java.nio.channels.Channel` 인터페이스에 정의된 두개의 메서드를 구현하였다.

[source,java]
.HexEncoderChannel.java#isOpen()
----
    // channel.isOpen() 값을 반환한다.
    // channel 이 null 이면 IllegalStateException 을 던진다.
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoderChannel.java[lines=60..66]
----

[source,java]
.HexEncoderChannel.java#close()
----
    // channel 이 null 이 아니면 channel.close() 를 호출한다.
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoderChannel.java[lines=75..80]
----

이제 `write(ByteBuffer)` 메서드를 다음과 같이 구현하였다.

[source,java]
.HexEncoderChannel.java#close()
----
include::../../../../hex-codec-api/src/main/java/com/github/jinahya/verbose/hex/HexEncoderChannel.java[lines=92..115]
----
<1> 버퍼가 `null` 이면 `capacity` 와 `direct` 값을 이용하여 생성한다.
<2> `encoder` 를 이용해 전달된 버퍼(`src`)의 내용을 `buffer`에 인코딩한다.
<3> 인코딩된 값을 `channel` 에 기록한다.
<4> `buffer` 에 남은 데이터가 한번에 모두 기록되지 않았다면 non-blocking mode 의 채널이라 가정하고 반복 구문을 빠져 나간다.
<5> `buffer` 에 남아 있는 모든 데이터를 `channel` 에 기록한다.

==== HexDecoderChannel.java

`HexDecoder` 인터페이스를 이용하여 `read(ByteBuffer)` 메서드에 전달된 버퍼에 디코딩된 바이트들을 저장하는 채널이다.

=== hex-codec-lib
hex-codec-api 모듈에 정의되어 있는 두개의 인터페이스를 구현할 모듈이다.

==== HexEncoderImpl.java
`HexEncoder` 인터페이스를 구현할 클래스이다.
[source,java]
.HexEncoderImpl.java
----
public class HexEncoderImpl implements HexEncoder {
    // @todo: implement
}
----
`encodeOctet(int, ByteBuffer)` 메서드를 구현하기 전에 네 개의 비트로 이루어진 숫자(nibble)를 한 개의 hex 문자로 변환하는 메서드를 정의해 보자.
[source,java]
.HexEncoderImpl#encodeNibble(int)
----
include::../../../../hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexEncoderImpl.java[lines=18..34]
----

주어진 값이 `0` 부터 `9` 까지의 값이면 그값에 `48` 을 더해서 '0'(`48`)부터 '9'(`57`)까지의 값을 반환하고 `10` 부터 `15` 까지의 값이면 그 값에 `55` 를 더해서 'A'(`65`)부터 'F'(`70`)까지의 값을 반환한다.

이제 `encodeOctet(int, ByteBuffer)` 를 다음과 같이 구현할 수 있다.
[source,java]
.HexEncoderImpl#encodeOctet(int, ByteBuffer)
----
include::../../../../hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexEncoderImpl.java[lines=36..42]
----
<1> octet을 오른쪽으로 `4` 만큼 쉬프트한 후 `15` 와 AND(`&`) 연산하여 상위 네 개의 비트가 표현하는 첫번째 nibble을 구한다.
<2> octet과 `15` 를 AND(`&`) 연산하여 하위 네 개의 비트가 표현하는 두번째 nibble을 구한다.

==== HexDecoderImpl.java
`HexDecoder` 인터페이스를 구현한 클래스이다.
[source,java]
.HexDecoderImpl.java
----
public class HexDecoderImpl implements HexDecoder {
    // @todo: implement
}
----
`decodeOctet(int)` 메서드를 구현하기 전에 한 개의 hex 문자를 네 개의 비트로 이루어진 숫자(nibble)로 변환하는 메서드를 정의해 보자.
[source,java]
.HexDecoderImpl#decodeNibble(int)
----
include::../../../../hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexDecoderImpl.java[lines=18..41]
----

주어진 값이 '0'(`48`, `0x30`)부터 '9'(`57`, `0x39`)까지의 문자이면 그 값에서 48을 뺀 값(`0` 부터 `9`)을, 대문자 'A'(`65`, `0x41`)부터 'F'(`70`, `0x46`) 까지의 값이면 그 값에서 `55` 를 뺀 값을, 소문자 'a'(`97`, `0x61`) 부터 'f'(`102`, `0x66`) 까지의 값이면 그 값에서 87를 뺀 값을 반환한다. (앞서 인코딩을 구현할 때는 무조건 대문자로 변환하였지만 디코딩을 할 때는 대문자 및 소문자를 모두 처리한다.)

이제 `decodeOctet(ByteBuffer)` 를 다음과 같이 구현할 수 있다.
[source,java]
.HexdecoderImpl#decodeOctet(ByteBuffer)
----
include::../../../../hex-codec-lib/src/main/java/com/github/jinahya/verbose/hex/HexDecoderImpl.java[lines=43..48]
----

=== Exercises
. `HexEncoderImpl#encodeNible(int)` 과 `HexDecoderImpl#decodeNibble(int)` 의 `switch` 구문을 `if/else` 구문으로 바꿔보자.
+
. `HexEncoder.java` 에 배열을 이용하는 메서드를 구현하라.
+
[source,java]
.HexEncoder#encode(byte[], int, int, byte[], int)
----
// inarr 의 inoff 부터 inlen 만큼의 숫자를 인코딩하고 결과를 outarr 의 outoff 부터 기록한다.
default void encode(final byte[] inarr, final int inoff, final int inlen,
                    final byte[] outarr, final int outoff) {
    // @todo: implement
    // 인자들의 유효성을 검증하자.
    // outarr 의 outoff 부터 최소한 몇 개의 배열공간이 필요할까?
}
----
. `HexDcoder.java` 에 배열을 이용하는 메서드를 구현하라.
+
[source,java]
.HexDecoder#encode(byte[], int, int, byte[], int)
----
// inarr 의 inoff 부터 inlen 만큼의 문자를 디코딩하고 결과를 outarr 의 outoff 부터 기록한다.
default void decode(final byte[] inarr, final int inoff, final int inlen,
                    final byte[] outarr, final int outoff) {
    // @todo: implement
    // 인자들의 유효성을 검증하자.
    // inlen 이 홀수이면 유효한 값일까?
    // outarr 의 outoff 부터 최소한 몇 개의 배열공간이 필요할까?
}
----
. `HexEncoderImplTest` 에 메서드들 하나 추가 하고 클래스 파일의 magic 바이트를 출력해 보자.
+
[source,java]
----
    @Test
    public void cafebaby() throws IOException {
        final Class<?> type = getClass();
        final String name = type.getSimpleName() + ".class";
        try (DataInputStream input
                = new DataInputStream(type.getResourceAsStream(name))) {
            final byte[] decodedBytes = new byte[4];
            input.readFully(decodedBytes);
            final byte[] encodedBytes = new byte[decodedBytes.length << 1];
            new HexEncoderImpl().encode(ByteBuffer.wrap(decodedBytes),
                                        ByteBuffer.wrap(encodedBytes));
            logger.info("magic: {}", new String(encodedBytes, US_ASCII));
        }
    }
----

=== percent-codec-api
다음과 같이 정의된 URL이 있다고 가정하자.
----
http://.../files/{file}?descriptor={descriptor}
----
`{file}` 부분과 `{descriptor}` 부분에 `a/b` 와 `c&d=e` 을 각각 대입하면 유효하지 않거나 의도와는 다른 값이 나온다.
----
http://.../files/a/b?descriptor=c&d=e
----
때문에 각 부분별로 허용되지 않는 문자들을 다음과 같이 적절하게 인코딩한 후 사용해야 한다.
----
http://.../files/a%2Fb?descriptor=c%26d%3De
----
https://tools.ietf.org/html/rfc3986[RFC 3986]의 https://tools.ietf.org/html/rfc3986#section-2.1https://tools.ietf.org/html/rfc3986#section-2.1[2.1. Percent-Encoding] 항목에 위 예시에서 사용된 방법이 정의되어 있다. 주어진 문자가 인코딩이 필요할 경우 https://tools.ietf.org/html/rfc3986#section-2.3[2.3. Unreserved Characters] 항목에 정의된 문자들(알파벳, 숫자, `"-"`, `"."`, `"_"`, `"~"`)이 아니면 `"%"` 문자 하나와 두개의 hex 문자로 표현한다.

==== PercentEncoder.java
Percent Encoding을 위한 인터페이스이다.
[source,java]
.PercentEncoder.java
----
public interface PercentEncoder {

    // octet(decoded)을 인코딩 한 후 결과를 버퍼(encoded)에 담는다.
    void encodeOctet(final int decoded, final ByteBuffer encoded);
}
----

==== PercentDecoder.java
Percent Decoding을 위한 인터페이스이다.
[source,java]
.PercentDecoder.java
----
public interface PercentDecoder {

    // 버버에서 필요한 만큼(1개 혹은 3개)의 문자를 디코딩하고 그 결과를 반환한다.
    int decodeOctet(final ByteBuffer encoded);
}
----

[NOTE]
================================================================================
http://docs.oracle.com/javase/8/docs/api/java/net/URLEncoder.html[`java.net.URLEncoder`] 와 http://docs.oracle.com/javase/8/docs/api/java/net/URLDecoder.html[`java.net.URLDecoder`] 는 해당 문서에 기술되어 있듯이 http://www.w3.org/TR/html5/forms.html#url-encoded-form-data[HTML]에 정의된 `application/x-www-form-urlencoded` 형식을 위한 코덱이다. `"~"` 대신 `"*"` 를 그대로 표기하며 공백 문자(`"{nbsp}"`)를 `"%20"` 이 아닌 `"+"` 로 인코딩한다. 아래 코드는 `"value"` 라는 필드 이름과 `"홍 길동"` 이라는 필드 값을 서버에 전달하는 HTTP 요청 문서의 예시이다. (공백 문자(`"{nbsp}"`)가 `"+"` 로 인코딩되어 있다.)
----
POST /names HTTP/1.1
Host: www.example.com:80
Content-Type: application/x-www-form-urlencoded
Content-Length: 34

value=%ED%99%8D+%EA%B8%B8%EB%8F%99
----
================================================================================

=== percent-codec-lib
pecent-codec-api 에 정의된 인터페이스들을 구현한 모듈이다. hex-codec-api 와 hex-codec-lib 을 통해 octet을 두개의 hex 문자로 변환하는 방법을 이미 구현했으므로 그 모듈들을 사용한다. 다음과 같이 의존성을 확인해 보자.

[source,text]
.percent-codec-lib/dependency:tree
--------------------------------------------------------------------------------
$ pwd
/.../path/to/.../verbose-java/percent-codec-lib
$ mvn dependency:tree -Dscope=runtime
...
[INFO] --- maven-dependency-plugin:x.y.z:tree (default-cli) @ percent-codec-lib ---
[INFO] com.github.jinahya:percent-codec-lib:jar:<version>
[INFO] +- com.github.jinahya:hex-codec-api:jar:<version>:compile
[INFO] +- com.github.jinahya:hex-codec-lib:jar:<version>:runtime
[INFO] \- com.github.jinahya:percent-codec-api:jar:<version>:compile
...
$
--------------------------------------------------------------------------------
hex-codec-api 를 compile scope 로 정의하여 구현작업에 사용되었고 hex-codec-lib 을 runtime scope 로 정의하여 실제로 동작할 때만 사용되도록 설정하였다.

==== PercentEncoderImpl.java

[source,java]
public class PercentEncoderImpl implements PercentEncoder {
    // @todo: implement
}

우선 다음과 같이 `HexEncoder` 개체를 적재하는 코드를 작성하자.
[source,java]
.PercentEncoderImpl.java#hexEncoder()
----
    protected HexEncoder hexEncoder() {
        if (hexEncoder == null) {
            try {
                hexEncoder = load(HexEncoder.class).iterator().next();
            } catch (final NoSuchElementException nsee) {
                throw new RuntimeException("no hex encoder loaded", nsee);
            }
        }
        return hexEncoder;
    }

    private HexEncoder hexEncoder;
----
그리고 다음과 같이 `encodeOctet(int, ByteBuffer)` 를 구현한다.
[source,java]
.PercentEncoderImpl.java#encodeOctet(int, ByteBuffer)
----
include::../../../../percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentEncoderImpl.java[lines=34..48]
----
<1> 인코딩할 필요가 없는 octet 이면 그대로 버퍼에 담는다.
<2> 인코딩이 필요한 문자는 한 개의 `"%"` 를 버퍼에 담고
<3> `HexEncoder` 에 정의된 `encodeOctet(int, ByteBuffer)` 를 이용해 두개의 hex 문자를 버퍼이 담는다.

==== PercentDecoderImpl.java

[source,java]
.PercentcoderImpl.java
----
public class PercentDecoderImpl implements PercentDecoder {
    // @todo: implement
}
----

`PercentEncoderImpl` 과 마찬가지로 `HexDecoder` 개체를 적재하는 코드를 작성하자.
[source,java]
.PercentDecoderImpl.java#hexDecoder()
----
    protected HexDecoder hexDecoder() {
        if (hexDecoder == null) {
            try {
                hexDecoder = load(HexDecoder.class).iterator().next();
            } catch (final NoSuchElementException nsee) {
                throw new RuntimeException("no hex decoder loaded", nsee);
            }
        }
        return hexDecoder;
    }

    private HexDecoder hexDecoder;
----
그리고 다음과 같이 `decodeOctet(int, ByteBuffer)` 를 구현한다.
[source,java]
.PercentDecoderImpl.java#decodeOctet(ByteBuffer)
----
include::../../../../percent-codec-lib/src/main/java/com/github/jinahya/verbose/percent/PercentDecoderImpl.java[lines=34..41]
----
<1> 첫 문자를 읽고 `"%"` 이면
<2> `HexDecoder` 에 정의된 `decodeOctet(ByteBuffer)` 를 이용해 두개의 hex 문자로부터 한 개의 octet 을 생성하고 반환한다.
<3> 인코딩이 필요치 않은 문자는 그대로 반환한다.
