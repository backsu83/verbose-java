== Hello World

[source,java]
----
public class SuccinctHelloWorld {

    public static void main(final String[] args) {
        System.out.println("hello, world");
    }
}
----
가능한 한 Hello World로 첫 장을 시작하고 싶지는 않았지만 기본적인 프로젝트를 설계하고 구현하는 방법을 살펴보기에 적절한 주제가 아닐 수 없다.

=== hello-world-api
우리가 앞으로 구현해 볼 인터페이스가 포함되어 있는 라이브러리이다.

==== SuccinctHelloworld.java
위에 있는 코드를 담고 있는 소스코드이다. 다음과 같이 실행해 보자.
[source,text]
----
$ pwd
/.../path/to/.../verbose-java
$ mvn -q -pl hello-world-api compile exec:java
hello, world
$
----

==== HelloWorld.java
우리가 구현할 인터페이스이다. 다음과 같이 한 개의 필드와 한 개의 메서드가 정의되어 있다.

[source,java]
----
public interface HelloWorld {

    // "hello, world"를 US-ASCII 문자셋으로 표현하기 위한 바이트 개수.
    int BYTES = 12;

    // 주어진 배열(array)의 명시된 위치(offset)부터 "hello, world"를 기록한다.
    // array가 null이면 NullPointerException을 던진다.
    // offset이 음수이면 ArrayIndexOutOfBoundsException을 던진다.
    // (offset + BYTES)가 array.length보다 크면 ArrayIndexOutOfBoundsException을 던진다.
    void set(byte[] array, int offset);
}
----

NOTE: 인터페이스에 선언된 모든 필드는 암묵적으로 `public`, `static`, and `final` 이다. [http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.3[JLS 9.3. Field (Constant) Declarations]]

NOTE: 인터페이스에 선언된 모든 메서드는 암묵적으로 `public` 이다. [http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.4[JLS 9.4. Method Declarations]]

=== hello-world-lib
위의 `hello-world-api` 를 구현할 라이브러리이다. 다음과 같이 의존성을 확인해 보자.

[source,text]
----
$ pwd
/.../verbose-java
$ mvn -pl hello-world-lib dependency:tree -Dscope=compile
...
[INFO] --- maven-dependency-plugin:x.y.z:tree (default-cli) @ hello-world-lib ---
[INFO] com.github.jinahya:hello-world-lib:jar:<version>
[INFO] \- com.github.jinahya:hello-world-api:jar:<version>:compile
...
$
----

==== HelloWorldImpl.java
`hello-world-api` 에서 정의한 `HelloWorld` 인터페이스를 구현할 클래스이다.

[source,java]
----
public class HelloWorldImpl implements HelloWorld {

    @Override
    public void set(final byte[] array, final int offset) {
        // @todo: implement
    }
}
----

==== HelloWorldImplTest.java
`HelloWorldImpl.java` 가 올바르게 구현되었는지를 확인하는 테스트 클래스이다.

[source,java]
----
public class HelloWorldImplTest {
    // @todo: create test cases for HelloWorldImpl.java
}
----

우리가 앞으로 구현할 `HelloWorldImpl#set(byte[], int)` 메서드를 테스트하기 전에 어떠한 기능들을 테스트해야 할지 미리 정리해 보자.

[options="header"]
.HelloWorld#set(byte[], int)을 위한 시험 항목
|=====================================================================================
|when |then
|`array` 가 `null` 이면 |`NullPointerException` 을 던진다.
|`offset` 이 `0` 보다 작으면 |`ArrayIndexOutOfBoundsException` 을 던진다.
|`offset + HelloWorld.BYTES` 가 `array.length` 보다 크면 |`ArrayIndexOutOfBoundsException` 을 던진다.
|모든 인자들이 적절하면 |`hello, world` 가 `array` 의 `offset` 위치 부터 기록된다.
|=====================================================================================

여기서 주의 할 점은 위에 열거된 조건을 실제 코드에서 구현한 순서가 다를 수도 있다는 것이다. `array.length` 부분때문에 세번째 항목(`offset + HelloWorld.BYTES > array.length`)에 해당하는 코드가 첫번째 항목(`array == null`)의 뒷부분에 있는 것은 당연하지만 두번째 항목(`offset < 0`)을 확인하는 조건문이 첫번째 항목(`array == null`)에 해당하는 조건문보다 먼저 작성되어 있을 수도 있다.

[source,java]
----
@Override
public void set(final byte[] array, final int offset) {
    if (offset < 0) // ...
    if (array == null) // ...
    if (offset + HelloWorld.BYTES > array.length) // ...
}
----
때문에 첫번째 항목(`array` 가 `null` 인 경우)을 테스트할 경우에는 두번째 조건에 위배되지 않는 `offset` 값을 사용해야 하며 두번째 항목(`offset` 이 음수일 경우)을 검증할때는 `array` 의 값으로 `null` 을 사용하면 안된다. 다음 테스트는 `array` 가 `null` 일 경우와 `offset` 이 음수일 경우를 한꺼번에 시험한다.

.SomeOtherHelloWorldImplTest#do_not_ever_test_like_this()
[source,java]
----
@Test
public void do_not_ever_test_like_this() {
    final byte[] array = null;
    final int offset = -1;
    try {
        new SomeOtherHelloWorldImpl().set(array, offset);
    } catch (final NullPointerException npe) {
        // array 를 먼저 확인하는 군!
    } catch (final ArrayIndexOutOfBoundsException aioobe) {
        // offset 을 먼저 확인하는 듯?
    }
}
----
이제 위에 열거된 네 개의 조건들에 대한 시험항목들을 작성하자.

TIP: 테스트 주도 개발(http://en.wikipedia.org/wiki/Test-driven_development[Test-driven development])이라고 하는 방법론을 적용해 보려 한다. 코드가 어떻게 동작해야 하는지에 대한 정확한 요구사항을 바탕으로 최소한의 범위에 한정하는 (그리고 실패하는) 시험 항목을 먼저 작성한 후 그 시험 항목이 성공할 만큼만 구현/수정 작업을 수행한다.

다음은 `array` 가 `null` 일 경우 `NullPointerException` 을 던지는지 확인하기 위한 시험 항목이다.

.HelloWorldImplTest#expectNullPointerExceptionWhenArrayIsNull
[source,java,indent=0]
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldImplTest.java[lines=32..37]
----

구현 항목을 작성하기 전에 테스트를 실행해보자.

[source,text]
----
$ mvn test
...
Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, ...
...
java.lang.AssertionError: a NullPointerException should've been thrown
	at org.testng.Assert.fail(Assert.java:XX)
	at ....HelloWorldImplTest.expectNullPointerExceptionWhenArrayIsNull(...)
...
$
----
(당연하게도) 실패하였다. `set(byte[], int)` 메서드에 `array` 의 값으로 `null` 을 전달했지만 `NullPointerException` 을 던지지 않았다. (사실, 아직 아무런 구현도 되어 있지 않다.) 이제 이 시험항목을 만족시키는 구현 항목을 작성하자.

[source,java]
----
@Override
public void set(final byte[] array, final int offset) {
    if (array == null) {
        throw new NullPointerException("null array");
    }
    // @todo: implement more
}
----
다시 테스트를 수행해보자.

[source,text]
----
$ mvn test
...
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
...
$
----

다음 항목은 `offset` 이 음수인 경우에 대한 시험 항목이다.

.HelloWorldImplTest#expectArrayIndexOutOfBoundsExceptionWhenOffsetIsNegative
[source,java,indent=0]
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldImplTest.java[lines=39..44]
----

마찬가지로 (아직 해당사항이 구현되어있지 않으므로) 테스트가 실패한다.

[source,text]
----
$ mvn test
...
Method HelloWorldImplTest.expectArrayIndexOutOfBoundsExceptionWhenOffsetIsNegative()[
...] should have thrown an exception of class java.lang.ArrayIndexOutOfBoundsException
...
Tests run: 2, Failures: 1, Errors: 0, Skipped: 0
...
$
----
다음과 같이 해당 항목을 구현하고 테스트를 실행한다.

.HelloWorldImpl#set(byte[], int)
[source,java]
----
@Override
public void set(final byte[] array, final int offset) {
    if (array == null) {
        throw new NullPointerException("null array");
    }
    if (offset < 0) {
        throw new ArrayIndexOutOfBoundsException(
                "offset(" + offset + ") < 0");
    }
}
----

[source,text]
----
$ mvn test
...
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
...
$
----

다음은 배열 공간이 충분하지 않을 경우에 대한 시험항목이다.

.HelloWorldImplTest#expectArrayIndexOutOfBoundsExceptionWhenCapacityIsNotEnough
[source,java,indent=0]
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldImplTest.java[lines=45..51]
----

실패하자.

[source,text]
----
$ mvn test
...
Method HelloWorldImplTest.expectArrayIndexOutOfBoundsExceptionWhenCapacityIsNotEnough()[
...] should have thrown an exception of class java.lang.ArrayIndexOutOfBoundsException
...
Tests run: 3, Failures: 1, Errors: 0, Skipped: 0
...
$
----
다음과 같이 해당 항목을 구현하고 테스트를 실행한다.

[source,java]
----
@Override
public void set(final byte[] array, final int offset) {
    if (array == null) {
        throw new NullPointerException("null array");
    }
    if (offset < 0) {
        throw new ArrayIndexOutOfBoundsException(
                "offset(" + offset + ") < 0");
    }
    if (offset + HelloWorld.BYTES > array.length) {
        throw new ArrayIndexOutOfBoundsException(
                "offset(" + offset + ")" + HelloWorld.BYTES
                + " > array.length(" + array.length + ")");
    }
}
----

[source,text]
----
$ mvn test
...
Tests run: 3, Failures: 0, Errors: 0, Skipped: 0
...
$
----

이제 마지막으로 모든 인자가 유효한 경우에 정상적으로 동작하는 것을 확인하는 시험 항목을 작성하고 (실패하는 것을 확인한 뒤) 해당 항목을 구현하자.

.HelloWorldImplTest#expectHelloWorldBytesSetOnArrayStartingAtOffset
[source,java,indent=0]
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldImplTest.java[lines=53..70]
----

실패!
[source,text]
----
$ mvn test
...
Method HelloWorldImplTest.expectHelloWorldBytesSetOnArrayStartingAtOffset()[
...
Tests run: 4, Failures: 1, Errors: 0, Skipped: 0
...
$
----

구현!

.HelloWorldImpl#set
[source,java,indent=0]
----
include::../../../../hello-world-lib/src/main/java/com/github/jinahya/verbose/hello/HelloWorldImpl.java[lines=24..50]
----

WARNING: `offset` 인자에 `final` 키워드를 생략한 다음 그 값을 직접 증가(`++`)시키면서 사용하였다. 좋은 방법이 아니다. 중간에 `offset` 값을 변경하는 코드가 삽입될 경우 정상적으로 동작하지 않는다. 가능한 한 메서드에 전달된 인자들에 `final` 키워드를 사용하여 에러가 발생할 확률을 줄인다. [http://checkstyle.sourceforge.net/config_misc.html#FinalParameters[Checkstyle#FinalParameters]]

****
다음과 같이 수정하고 부가적으로 발생하는 문제점(들)을 해결하라.

[line-through]#`public void set(final byte[] array, int offset) {`#

`public void set(final byte[] array, final int offset) {`
****

이제 모든 시험 항목들을 실행해보자.

[source,text]
----
$ mvn test
...
Tests run: 4, Failures: 0, Errors: 0, Skipped: 0
...
$
----

WARNING: `HelloWorldImplTest#expectHelloWorldBytesSetOnArrayStartingAtOffset()` 에서 `offset` 으로부터의 상대적인 위치를 표기하기 위해  2진수(`0b____`)를 사용하였다. 이를 8진수와 16진수로 각각 변경하라. [https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.1[JLS §3.10.1. Integer Literals]]

==== HelloWorldDataProvider.java
지금까지 우리는 `HelloWorldImplTest` 에서 `HelloWorldImpl` 의 기능을 시험하기 위해 (각각의 단위 시험 항목에서) 다음과 같은 작업을 수행했다.

- 시험 항목의 목적에 해당하는 `array` 와 `offset` 을 준비한다.
- `HelloWorldImpl` 객체를 생성하고 `set(array, offset)` 을 호출한다.

지금부터는 위에 정리된 항목들 중 **단위 시험 항목에서 사용할 데이터를 제공**하는 방법과 **시험을 수행할 객체를 생성**하는 방법에 대해서 알아보려 한다.

TestNG에서 제공하는 데이터 제공자(Data Provider)를 사용하면 시험 항목에 필요한 **데이터를 인자로 제공**받을 수 있을 뿐만 아니라 아래 표에 정리된 것과 같이 **1개 이상의 시험 데이터**를 전달받아 여러 경우에 대해 테스트를 실행할 수 있다. 아래 표는 우리가 이미 시험항목에서 사용한 데이터와 추가적으로 사용 가능한 데이터를 보여준다.

[options="header"]
.시험 데이터
|===============================================================================
|case                |array                         |offset
|**arrayNull**       |**null**                      |** 0**
|                    |null                          |   1
|**offsetNegative**  |**new byte[HelloWorld.BYTES]**|**-1**
|                    |new byte[HelloWorld.BYTES - 1]|  -2
|                    |new byte[HelloWorld.BYTES - 2]|  -3
|**notEnoughSpace**  |**new byte[HelloWorld.BYTES]**|** 1**
|                    |new byte[HelloWorld.BYTES + 1]|   2
|                    |new byte[HelloWorld.BYTES + 2]|   3
|                    |new byte[HelloWorld.BYTES + 3]|   4
|*parametersAreAllOk*|**new byte[HelloWorld.BYTES]**|** 0**
|                    |new byte[HelloWorld.BYTES + 1]|   1
|                    |new byte[HelloWorld.BYTES + 2]|   2
|                    |new byte[HelloWorld.BYTES + 3]|   3
|                    |new byte[HelloWorld.BYTES + 4]|   4
|===============================================================================

`HelloWorld` 를 위한 시험 항목들이 사용할 시험 데이터를 제공하는 클래스를 만들어 보자.

[source,java]
.HelloWorldDataProvider.java
----
class HelloWorldDataProvider {
    // @todo: implement
}
----
다음은 `array` 가 `null` 인 경우를 위한 데이터를 제공하는 메서드이다.

[source,java,indent=0]
.HelloWorldDataProvider#provideArrayNotNull
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldDataProvider.java[lines=29..35]
----

다음은 `offset` 이 음수인 경우에 해당하는 데이터를 제공하는 메서드이다.

[source,java,indent=0]
.HelloWorldDataProvider#provideOffsetNegative
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldDataProvider.java[lines=37..44]
----

다음은 공간이 충분하지 않은 경우에 대한 데이터를 제공하는 메서드이다.

[source,java,indent=0]
.HelloWorldDataProvider#provideCapacityNotEnough
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldDataProvider.java[lines=46..54]
----

NOTE: 데이터 제공자의 반환값은 `Object[][]` 혹은 `Iterator<Object[]>` 형으로 작성해야 한다. 두 경우 모두 실제 시험 항목의 인자들(`Object[]{array, offset}`)을 1개 이상 제공하기 위한 형태이다.

==== HelloWorldDataTest.java
`HelloWorldDataProvider` 클래스가 제공하는 데이터를 사용하는 단위 시험 클래스를 작성해보자.

[source,java]
.HelloWorldDataTest.java
----
abstract class HelloWorldDataTest {

    abstract HelloWorld implementation();
}
----
추상클래스로 작성되었으며 이 클래스를 확장하는 클래스에서 `implementation()` 메서드를 구현함으로써 `set(byte[], int)` 을 호출할 객체를 제공하도록 하였다.

우선 `array` 가 `null` 인 경우에 대한 시험 항목을 작성해 보자.

[source,java,indent=0]
.HelloWorldDataTest#testArrayNull(byte[], int)
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldDataTest.java[lines=49..54]
----

`@Test` 어노테이션의 `dataProvider` 요소와 `dataProviderClass` 요소를 이용하여 데이터 제공자를 명시하였다. TestNG는 시험항목을 호출할 때 데이터 제공자가 반환하는 데이터를 시험 항목의 인자(`byte[], int`)로 전달한다.

다음은 `offset` 이 음수인 경우를 위한 시험 항목이다.

[source,java,indent=0]
.HelloWorldDataTest#testOffsetNegative(byte[], int)
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldDataTest.java[lines=67..72]
----

다음은 공간이 충분하지 않은 경우를 위한 시험 항목이다.

[source,java,indent=0]
.HelloWorldDataTest#testCapacityNotEnough(byte[], int)
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldDataTest.java[lines=86..91]
----

****
`set(byte[], int)` 메서드가 사용하기에 문제가 없는 데이터를 제공하는 데이터 제공자와 그로부터 데이터를 제공받아 정상적인 동작을 확인하는 시험 항목을 작성하라.
[source,java]
.HelloWorldDataProvider#provideValid()
----
@DataProvider
static Object[][] provideValid() {
    // @todo: implement
    return null;
}
----
[source.java]
.HelloWorldDataTest#testValid(byte[], int)
----
@Test(dataProvider = "provideValid"
      dataProviderClass = HelloWorldDataProvider.class)
public void testValid(final byte[] array, final int offset) {
    implementation().set(array, offset);
    // @todo: verify
}
----
****

이제 데이터 제공자와 단위 시험 항목들이 준비되었다. 다음은 `implemention()`메서드를 구현하는 클래스를 만들어보자.

****
다음과 같은 방법은 생략한다.
[source,java]
----
public class AwesomeHelloWorldDataTest extends HelloWorldDataTest {

    @Override
    HelloWorld implementation() {
        return new HelloWorldImpl(); // Awesome!
    }
}
----
****

==== HelloWorldInjectionTest.java

의존성 주입(Dependency injection)이라는 패턴을 사용보려 한다. [https://jcp.org/en/jsr/detail?id=330[JSR 330: Dependency Injection for Java]]에서 정의된 API를 이용한다.

****
`hello-world-api` 모듈에는 `HelloWorld` 를 구현한 `HelloWorldDemo` 라는 클래스가 있다. 보다 많은 의존성 주입 사례를 위해 우리가 이미 구현한 `HelloWorldImpl` 클래스와 같이 사용한다.
****

[source,java]
.HelloWorldInjectionTest.java
--------------------------------------------------------------------------------
abstract class HelloWorldInjectionTest extends HelloWorldDataTest {

    @Inject
    HelloWorld any;

    @Inject
    @Named("demo")
    HelloWorld namedAsDemo;

    @Inject
    @Named("impl")
    HelloWorld namedAsImpl;

    @Inject
    @QualifiedDemo
    HelloWorld qualifiedWithDemo;

    @Inject
    @QualifiedImpl
    HelloWorld qualifiedWithImpl;
}
--------------------------------------------------------------------------------
`@javax.inject.Inject` 어노테이션을 상용함으로써 외부로부터 주입된다는 것을 선언하였다. `any` 필드에는 `HelloWorldDemo` 와 `HelloWorldImpl` 중 어느 구현체가 주입될지는 모른다. `namesAsDemo` 필드와 `namedAsImpl` 필드에는 `@javax.inject.Named` 어노테이션을 사용하여 미리 약속된 문자열(`"demo"`, `"impl"`)을 통해 원하는 형태의 구현체를 주입받는다. `qualifedWithDemo` 필드와 `qualifiedWithImpl` 필드는 `@javax.inject.Qualifier` 어노테이션이 적용된 별도의 어노테이션들을 사용하여 원하는 형태의 값을 주입받는다

****
`@QualifiedDemo` 과 `@QualifiedImpl` 어노테이션의 정의는 다음과 갈다.

[source,java,indent=0]
.QualifiedDemo.java
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/QualifiedDemo.java[lines=32..36]
----

[source,java,indent=0]
.QualifiedImpl.java
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/QualifiedImpl.java[lines=32..36]
----
****

이제 다음과 같이 `implementation()`을 구현하자. 앞서 정의된 다섯개의 필드중 하나를 랜덤으로 반환한다.

[source,java]
.HelloWorldInjectionTest#implementation()
--------------------------------------------------------------------------------
@@Override
HelloWorld implementation() {
    switch (current().nextInt(5)) {
        case 0:
            return any;
        case 1:
            return namedAsDemo;
        case 2:
            return namedAsImpl;
        case 3:
            return qualifiedWithDemo;
        default:
            return qualifiedWithImpl;
    }
}
--------------------------------------------------------------------------------

이제 실제로 주입작업을 실행하는 클래스를 만들어 보자. https://github.com/google/guice[Guice] 라는 프레임워크를 사용한다.

NOTE: 보통의 경우 주입(injection)작업은 의존성 주입을 지원하는 컨테이너에서 이루어지지만 여기서는 직접 주입작업을 수행한다.

Guice를 사용하여 주입작업을 수행하기 위해서는 실제로 주입을 필요로 하는 요소들(필드, 메서드 등)에 따라서 주입형태를 설정하는 모듈이 필요하다. `com.google.inject.AbstractModule` 클래스를 구현하는 모듈을 하나 정의하자.

[source,java]
.HelloWorldGuilceModule.java
----
class HelloWorldGuiceModule extends AbstractModule {

    @Override
    protected void configure() {
        // @todo: configure
    }
}
----

`any` 필드에는 `HelloWorldDemo` 와 `HelloWorldImpl` 중 랜덤으로 선택된 형태를 주입한다.

[source,java,indent=0]
.QualifiedImpl.java
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldGuiceModule.java[lines=33..35]
----

`@Named("demo")` 혹은 `@Named("impl")` 이 적용된 필드들에는 각각의 형태를 주입한다.

[source,java,indent=0]
.QualifiedImpl.java
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldGuiceModule.java[lines=36..41]
----

`@QualifiedDemo` 혹은 `@QualifiedImpl` 어노테이션이 적용된 필드들을 구분하여 각각의 형태를 주입한다.

[source,java,indent=0]
.QualifiedImpl.java
----
include::../../../../hello-world-lib/src/test/java/com/github/jinahya/verbose/hello/HelloWorldGuiceModule.java[lines=42..47]
----

이제 위에서 정의한 모듈을 이용하여 주입작업을 수행하는 테스트 클래스를 작성한다.

[source,java]
.HelloWorldGuiceTest.java
----
public class HelloWorldGuiceTest extends HelloWorldInjectionTest {

    @BeforeClass
    void inject() {
        final Injector injector
                = Guice.createInjector(new HelloWorldGuiceModule());
        injector.injectMembers(this);
    }
}
----

다음과 같이 실제로 주입작업이 잘 수행되었는지 테스트를 실행해보자.

[source,text]
----
$ pwd
/.../path/to/.../verbose-java
$ mvn -pl hello-world-lib -Dtest=HelloWorldGuiceTest test
...
$
----

`hello-world-lib` 에는 Guice 이외에 [https://jcp.org/en/jsr/detail?id=330[JSR 330: Dependency Injection for Java]]을 지원하는 몆몆 프레임워크를 사용하는 별도의 테스트 클래스들이 추가되어 있다.

[options="header"]
.JSR 330 Implementations
|===============================================================================
|framework       |profile  |url
|Dagger          |`dagger` |http://square.github.io/dagger/
|Dagger 2        |`dagger2`|http://google.github.io/dagger/
|HK2             |`hk2`    |https://hk2.java.net/
|Spring Framework|`spring` |http://projects.spring.io/spring-framework/
|===============================================================================

소스코드는 `src/test/java-<profile>` 위치에 있으며 다음과 같이 테스트해 볼 수 있다.

[source,text]
----
$ pwd
/.../path/to/.../verbose-java
$ mvn -pl hello-world-lib -P<profile> test
...
$
----

==== HelloWorldServiceTest.java
이번에는 자바에서 지원하는 확장 메커니즘을 활용하여 `implementation()` 메서드를 구현해보려 한다. 서비스 확장의 목적은 라이브러리가 수행할 기능을 인터페이스나 추상클래스로 정의(Service Provider Interface)한 후 그 기능을 구현한 제공자(Service Provider)를 선택적으로 사용할 수 있도록 하는 것이다.

[source,java]
----
public class HelloWorldServiceTest extends HelloWorldDataTest {

    @Override
    HelloWorld implementation() {
        return implementation;
    }

    private HelloWorld implementation; // @todo: initialize
}
----
`HelloWorld` 형의 변수를 하나 선언하고 `implementation()` 메서드에서는 그 값을 반환하도록 하였다.

이제 우리가 구현한 `HelloWorldImpl` 이 `HelloWorld` 를 구현했다는 사항을 추가하면 된다. `META-INF/services` 디렉토리에 구현한 인터페이스의 이름과 같은 파일을 생성한 후 그 안에 우리가 구현한 클래스의 이름을 기록한다.

[source,text]
----
.
|-- pom.xml
`-- src/
    |-- main/
    |   |-- java/...
    |   `-- resources/
    |       `-- META-INF/
    |           `-- services/
    |               `-- com.github.jinahya.verbose.hello.HelloWorld
    `-- test/
        `-- java/...
----

이제 `....hello.HelloWorld` 파일에 다음과 같이 이미 구현한 `HelloWorldImpl` 의 클래스명을 기록한다.

[source,text]
.META-INF/services/com.github.jinahya.verbose.hello.HelloWorld
----
com.github.username.verbose.hello.HelloWorldImpl

----
이제 서비스를 적재하여 `implementation` 변수의 값을 기록하자.

[source,java]
.HelloWorldServiceProviderTest#implementation()
----
@Override
HelloWorld implementation() {
    if (implementation == null) {
        final ServiceLoader<HelloWorld> loader
                = ServiceLoader.load(HelloWorld.class);
        final Iterator<HelloWorld> iterator = loader.iterator();
        try {
            implementation = iterator.next();
        } catch (final NoSuchElementException nsee) {
            fail("failed to load an implementation", nsee);
        }
    }
    return implementation;
}
----
다음과 같이 테스트를 수행해보자.

[source,text]
----
$ pwd
/.../path/to/.../verbose-java
$ mvn -pl hello-world-lib -Dtest=HelloWorldServiceTest test
...
$
----

****
`META-INF/services/com.....HelloWorld` 파일의 내용을 변경하여 `HelloWorldImpl` 대신 `HelloWorldDemo` 를 사용하도록 설정한 후 변경작업이 적용되었는지 확인하라.
[source,text]
.META-INF/services/com.github.jinahya.verbose.hello.HelloWorld
----
#com.github.username.verbose.hello.HelloWorldImpl
com.github.username.verbose.hello.HelloWorldDemo

----
****

=== hello-world-app
지금까지 우리는 성공적으로 `hello-world-api` 를 구현하였다. 상세한 시험 항목을 통해 우리가 구현한 코드가 의도한데로 그리고 정상적으로 동작하는 것을 확인하였다. 또한 의존성 주입 및 서비스 확장이라는 개념까지 살펴보았다. 이제 우리는 우리가 직접 구현한 코드를 가지고 본 장 첫 부분에서 보았던 `SuccinctHelloWorld` 프로그램과 동일한 기능을 수행하는 프로그램을 만들 수 있다.

[source,text]
----
$ pwd
/.../path/to/.../verbose-java
$ mvn -pl hello-world-app dependency:tree -Dscope=compile
...
[INFO] --- maven-dependency-plugin:x.y.z:tree (default-cli) @ hello-world-app ---
[INFO] com.github.jinahya:hello-world-app:jar:<version>
[INFO] \- com.github.jinahya:hello-world-lib:jar:<version>:compile
[INFO]    \- com.github.jinahya:hello-world-api:jar:<version>:compile
...
$
----

==== HelloWorldMain.java
우리가 작성한 `HelloWorldImpl` 을 이용하여 `hello, world%n` 을 인쇄하는 프로그램이다. 앞서 구현했던 서비스 확장 기능을 사용한다.

[source,java]
.HelloWorldMain.java
----
public class HelloWorldMain {

    public static void main(final String[] args) {
        final HelloWorld loaded = load(HelloWorld.class).iterator().next();
        final byte[] array = new byte[HelloWorld.BYTES];
        final int offset = 0;
        loaded.set(array, offset);
        final String string = new String(array, US_ASCII);
        System.out.printf("%s%n", string);
    }
}
----
다음과 같이 실행해 보자.

[source,text]
----
$ pwd
/.../path/to/.../verbose-java
$ mvn -q -pl hello-world-app compile exec:java
hello, world
$
----

==== 실행 가능한 jar 파일 생성하기
`HelloWorldMain` 클래스를 실행하기 위해서는 `hello-world-api` 와 `hello-world-lib` 이 필요하다. 몇몇 플러그인을 이용하여 실행에 필요한 파일들을 모두 포함하는 실행 가능한 jar파일을 생성해 보자.

===== Apache Maven Assembly Plugin
다음은 http://maven.apache.org/plugins/maven-assembly-plugin/[Apache Maven Assembly Plugin]의 `jar-with-dependencies` 설명자(descriptor)를  이용하는 방법이다.

[source,xml]
.maven-assembly-plugin:single
----
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-assembly-plugin</artifactId>
  <executions>
    <execution>
      <id>assembly-single</id>
      <phase>package</phase>
      <goals>
        <goal>single</goal>
      </goals>
      <configuration>
        <archive>
          <manifest>
            <mainClass>${mainClass}</mainClass>
          </manifest>
        </archive>
        <descriptorRefs>
          <descriptorRef>jar-with-dependencies</descriptorRef>
        </descriptorRefs>
      </configuration>
    </execution>
  </executions>
</plugin>
----
다음과 같이 실행해 볼 수 있다.

[source.text]
----
$ pwd
/.../path/to/.../verbose-java
$ mvn -Dmaven.test.skip=true package
...
$ java -jar hello-world-app/target/hello-world-app-<version>-jar-with-dependencies.jar
hello, world
$
----

===== Apache Maven Shade Plugin

[source,xml]
.maven-shade-plugin:shade
----
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-shade-plugin</artifactId>
  <executions>
    <execution>
      <id>shade-shade</id>
      <goals>
        <goal>shade</goal>
      </goals>
      <configuration>
        <shadedArtifactAttached>true</shadedArtifactAttached>
        <transformers>
          <transformer implementation=
           "org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
            <mainClass>${mainClass}</mainClass>
          </transformer>
        </transformers>
      </configuration>
    </execution>
  </executions>
</plugin>
----
`shadedArtifactAttached` 프로퍼티를 사용해서 별도의 jar파일을 만들도록 설정하였다. 다음과 같이 실행해 볼 수 있다.

[source,text]
----
$ pwd
/.../path/to/.../verbose-java
$ mvn -Dmaven.test.skip=true package
...
$ java -jar hello-world-app/target/hello-world-app-<version>-shaded.jar
hello, world
$
----

===== Spring Boot Maven Plugin
`spring-boot:repackage` 를 이용할 수도 있다.

[source,xml]
----
<plugin>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-maven-plugin</artifactId>
  <executions>
    <execution>
      <id>spring-boot-repackage</id>
      <goals>
        <goal>repackage</goal>
      </goals>
      <configuration>
        <classifier>spring-boot</classifier>
        <mainClass>${mainClass}</mainClass>
      </configuration>
    </execution>
  </executions>
</plugin>
----

`classifier` 속성을 사용하여 별도의 jar 파일을 생성하도록 설정하였다. 다음과 같이 실행해 볼 수 있다.

[source.text]
----
$ pwd
/.../path/to/.../verbose-java
$ mvn -Dmaven.test.skip=true package
...
$ java -jar hello-world-app/target/hello-world-app-<version>-spring-boot.jar
hello, world
$
----

****
위에서 생성된 jar 파일들의 `META-INF/MANIFEST.MF` 항목의 내용을 확인하라.

[source.text]
----
$ pwd
/.../path/to/.../verbose-java
$ unzip -p hello-world-app/target/hello-world-app-<version>-<classifier>.jar META-INF/MANIFEST.MF
...
$
----
****
